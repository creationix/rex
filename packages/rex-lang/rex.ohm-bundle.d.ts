// AUTOGENERATED FILE
// This file was generated from rex.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface RexActionDict<T> extends BaseActionDict<T> {
  space?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  Program?: (this: NonterminalNode, arg0: IterationNode) => T;
  Expr_binding?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expr_call?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  Expr_atom?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom_string?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom_number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom_bytes?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom_boolean?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom_null?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom_undefined?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom_array?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom_object?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom_symbol?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Atom?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Array?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Object?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Bytes?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  HexByte?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  Pair?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Any?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
  String?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DQuotedString?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  dStringChar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  SQuotedString?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  sStringChar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  escape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode | TerminalNode) => T;
  unicodeEscape?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: NonterminalNode) => T;
  hex?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  Number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  hexNumber?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode) => T;
  binaryNumber?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode) => T;
  decimalNumber?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode) => T;
  decimalInteger_nonZero?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  decimalInteger_zero?: (this: NonterminalNode, arg0: TerminalNode) => T;
  decimalInteger?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  bit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  exponent?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  bareWord?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  Boolean?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Null?: (this: NonterminalNode, arg0: TerminalNode) => T;
  Undefined?: (this: NonterminalNode, arg0: TerminalNode) => T;
  nonZeroDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  lineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  blockComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
}

export interface RexSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: RexActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: RexActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: RexActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: RexActionDict<T>): this;
}

export interface RexGrammar extends Grammar {
  createSemantics(): RexSemantics;
  extendSemantics(superSemantics: RexSemantics): RexSemantics;
}

declare const grammar: RexGrammar;
export default grammar;

